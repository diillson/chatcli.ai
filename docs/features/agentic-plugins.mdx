---
title: "IA Agentiva e Sistema de Plugins"
sidebarTitle: "IA Agentiva e Plugins"
description: "Transforme o ChatCLI em uma plataforma de automaÃ§Ã£o extensÃ­vel. Crie ferramentas customizadas que a IA pode usar autonomamente para executar fluxos de trabalho complexos de ponta a ponta."
icon: "smart_toy"
---


## De Assistente a Agente: Uma MudanÃ§a de Paradigma

A maioria das ferramentas de IA para linha de comando funciona como **assistentes**: vocÃª pergunta, elas respondem. O ChatCLI vai alÃ©m, transformando a IA em um **agente autÃ´nomo** que nÃ£o apenas responde, mas **age**.

O sistema de Plugins e IA Agentiva materializa essa visÃ£o:

- **VocÃª**: Define o objetivo e fornece as ferramentas (plugins)
- **O Agente**: Orquestra a execuÃ§Ã£o, conectando percepÃ§Ã£o, raciocÃ­nio e aÃ§Ã£o para resolver problemas complexos

Esta nÃ£o Ã© apenas uma funcionalidade â€” Ã© a fundaÃ§Ã£o para um novo modo de interagir com seu ambiente de desenvolvimento.

---

## Arquitetura do Sistema de Plugins

### Descoberta e Carregamento AutomÃ¡tico

O ChatCLI utiliza um **gerenciador de plugins inteligente** que:

1. **Monitora o diretÃ³rio** `~/.chatcli/plugins/` usando `fsnotify`
2. **Detecta mudanÃ§as** em tempo real (criaÃ§Ã£o, modificaÃ§Ã£o, remoÃ§Ã£o de arquivos)
3. **Aplica debounce** de 500ms para evitar recarregamentos mÃºltiplos
4. **Valida o contrato** de cada plugin antes de carregÃ¡-lo
5. **Recarrega automaticamente** sem necessidade de reiniciar o ChatCLI

```go
// Eventos que acionam hot reload:
// - Write:  ModificaÃ§Ã£o de arquivo existente
// - Create: Novo plugin adicionado
// - Remove: Plugin deletado
// - Rename: Plugin renomeado
```
### Busca FlexÃ­vel de Plugins

O sistema aceita ambas as formas de invocaÃ§Ã£o:

- Com @ (forma canÃ´nica)
  - /agent @hello mundo

- Sem @ (atalho conveniente)
  - /agent hello mundo

Internamente, o gerenciador normaliza automaticamente:
```go
func (m *Manager) GetPlugin(name string) (Plugin, bool) {
    p, ok := m.plugins[name]
    if !ok {
        p, ok = m.plugins["@"+name]  // Fallback automÃ¡tico
    }
    return p, ok
}
```
--------

## ConfiguraÃ§Ã£o do Agente

### VariÃ¡veis de Ambiente

Configure o comportamento do agente atravÃ©s de variÃ¡veis de ambiente:

# Controle de ExecuÃ§Ã£o
`CHATCLI_AGENT_PLUGIN_MAX_TURNS=10`     # MÃ¡ximo de iteraÃ§Ãµes (padrÃ£o: 7)

`CHATCLI_AGENT_PLUGIN_TIMEOUT=20m`       # Timeout por plugin (padrÃ£o: 15m)

# SeguranÃ§a
`CHATCLI_AGENT_CMD_TIMEOUT=5m`           # Timeout para comandos shell

`CHATCLI_AGENT_DENYLIST="rm.*-rf.*;dd.*"` # PadrÃµes regex bloqueados

`CHATCLI_AGENT_ALLOW_SUDO=false`         # Bloqueia sudo por padrÃ£o

```bash
VariÃ¡vel                        â”‚ Tipo     â”‚ PadrÃ£o  â”‚ DescriÃ§Ã£o                                                                         
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CHATCLI_AGENT_PLUGIN_MAX_TURNS  â”‚ inteiro  â”‚  7      â”‚ NÃºmero mÃ¡ximo de iteraÃ§Ãµes do ciclo ReAct. Evita loops infinitos.                 
CHATCLI_AGENT_PLUGIN_TIMEOUT    â”‚ duraÃ§Ã£o  â”‚  15m    â”‚ Tempo limite para execuÃ§Ã£o de cada plugin. Aceita formato Go ( 30s ,  5m ,  1h ).
CHATCLI_AGENT_CMD_TIMEOUT       â”‚ duraÃ§Ã£o  â”‚  10m    â”‚ Timeout para comandos shell executados via  @command .                            
CHATCLI_AGENT_DENYLIST          â”‚ string   â”‚ -       â”‚ ExpressÃµes regulares separadas por  ;  para bloquear comandos perigosos.          
CHATCLI_AGENT_ALLOW_SUDO        â”‚ booleano â”‚  false  â”‚ Permite comandos  sudo  sem bloqueio automÃ¡tico (use com cautela).
```
--------

## O Ciclo ReAct: RaciocÃ­nio e AÃ§Ã£o

O AgentMode implementa o framework ReAct (Reasoning and Acting), um loop iterativo transparente:

### 1. RaciocÃ­nio (Pensamento)

O agente analisa o objetivo e verbaliza seu plano:
```bash
<pensamento>
O objetivo Ã© analisar a performance de uma funÃ§Ã£o Go. 
Isso requer profiling. Olhando minhas ferramentas, vejo 
@go-bench-gen e @go-bench-run. O primeiro passo lÃ³gico 
Ã© gerar o arquivo de benchmark.
</pensamento>
```
### 2. AÃ§Ã£o (Chamada de Ferramenta)

A IA formaliza sua decisÃ£o em uma chamada estruturada:
```bash
<tool_call name="@go-bench-gen" args="main.go MinhaFuncao" />
```
### 3. ExecuÃ§Ã£o (InvocaÃ§Ã£o do Plugin)

O ChatCLI intercepta e executa o plugin:
```go
ğŸ¤– Agente estÃ¡ usando a ferramenta: @go-bench-gen main.go MinhaFuncao
   â³ Timeout configurado: 15m
   ğŸ“‚ DiretÃ³rio: /home/user/projeto
```
### 4. ObservaÃ§Ã£o (Feedback)

O resultado Ã© formatado e retornado para a IA:
```go
--- Resultado da Ferramenta ---
âœ… Arquivo gerado: main_bench_test.go
ğŸ“Š Benchmark criado: BenchmarkMinhaFuncao
```
### 5. ReiteraÃ§Ã£o

O ciclo recomeÃ§a atÃ© que o objetivo seja alcanÃ§ado ou o limite de turnos seja atingido.

--------

## Gerenciamento de Plugins com  /plugin

### Comandos DisponÃ­veis
```bash
Comando                   â”‚ DescriÃ§Ã£o                                          
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/plugin list              â”‚ Lista todos os plugins instalados com metadados    
/plugin install <url>     â”‚ Instala plugin de um repositÃ³rio Git (linguagens copilada)              
/plugin show <nome>       â”‚ Exibe descriÃ§Ã£o e sintaxe de uso                   
/plugin inspect <nome>    â”‚ Mostra metadados brutos, caminho e permissÃµes      
/plugin uninstall <nome>  â”‚ Remove plugin do sistema                           
/plugin reload            â”‚ ForÃ§a recarregamento manual (raramente necessÃ¡rio)
```
### Exemplo de Uso

# Listar plugins disponÃ­veis
```go
â¯ /plugin list
ğŸ“¦ Plugins Instalados (3):
  â€¢ @go-bench-gen  - Gera arquivos de benchmark Go
  â€¢ @go-bench-run  - Executa benchmarks e profiling
  â€¢ @dockerhub     - Consulta tags do Docker Hub
```
# Ver detalhes de um plugin
```go
â¯ /plugin show @go-bench-gen
ğŸ“‹ Plugin: @go-bench-gen
ğŸ“ DescriÃ§Ã£o: Gera arquivos de benchmark Go a partir de funÃ§Ãµes existentes
ğŸ’¡ Uso: @go-bench-gen <arquivo.go> <NomeDaFuncao>
ğŸ·ï¸  VersÃ£o: 1.2.0
```
# Inspecionar metadados tÃ©cnicos
```go
â¯ /plugin inspect @go-bench-gen
ğŸ” InspeÃ§Ã£o Detalhada:
   Caminho: /home/user/.chatcli/plugins/go-bench-gen
   PermissÃµes: -rwxr-xr-x
   Tamanho: 2.3 MB
   
   Metadados (JSON):
   {
     "name": "@go-bench-gen",
     "description": "Gera arquivos de benchmark Go",
     "usage": "@go-bench-gen <arquivo.go> <NomeDaFuncao>",
     "version": "1.2.0"
   }
```
### InstalaÃ§Ã£o de Plugins

# Instalar de um repositÃ³rio Git
> â¯ /plugin install https://github.com/usuario/chatcli-plugin-k8s.git
```go
âš ï¸  AVISO DE SEGURANÃ‡A
VocÃª estÃ¡ prestes a instalar cÃ³digo de terceiros que serÃ¡ executado 
em sua mÃ¡quina. Revise o cÃ³digo-fonte antes de prosseguir.

RepositÃ³rio: https://github.com/usuario/chatcli-plugin-k8s.git
Confirmar instalaÃ§Ã£o? (s/N): s

ğŸ“¥ Clonando repositÃ³rio...
ğŸ”¨ Detectado projeto Go, compilando...
âœ… Plugin @k8s instalado com sucesso!
```
--------

## Criando Plugins: O Guia Completo

### O Contrato do Plugin

Todo plugin deve seguir estas regras:

#### 1. Ser um ExecutÃ¡vel

- BinÃ¡rio compilado (Go, Rust, C++) ou
- Script com shebang ( #!/usr/bin/env python3 ,  #!/bin/bash )
- Localizado em  ~/.chatcli/plugins/
- PermissÃ£o de execuÃ§Ã£o obrigatÃ³ria ( chmod +x )

# Verificar permissÃµes
```bash
ls -l ~/.chatcli/plugins/
-rwxr-xr-x  1 user  staff  2.3M  meu-plugin  # âœ… Correto (x = executÃ¡vel)
-rw-r--r--  1 user  staff  1.8M  outro       # âŒ Sem permissÃ£o de execuÃ§Ã£o
```
#### 2. Responder ao Contrato  --metadata  (ObrigatÃ³rio)

Quando invocado com  --metadata , o plugin DEVE imprimir um JSON vÃ¡lido para  stdout :
```json
{
  "name": "@meu-plugin",
  "description": "DescriÃ§Ã£o clara do que o plugin faz",
  "usage": "@meu-plugin <arg1> [--flag]",
  "version": "1.0.0"
}
```
Todos os campos sÃ£o obrigatÃ³rios:

-  name : Deve comeÃ§ar com  @
-  description : Usado pela IA para decidir quando usar a ferramenta
-  usage : Sintaxe de invocaÃ§Ã£o
-  version : Versionamento semÃ¢ntico

#### 3. Implementar  --schema  (Opcional, mas Recomendado)

O schema ajuda a IA a entender os parÃ¢metros do plugin:
```json
{
  "parameters": [
    {
      "name": "cluster-name",
      "type": "string",
      "required": true,
      "description": "Nome do cluster Kubernetes"
    },
    {
      "name": "namespace",
      "type": "string",
      "required": false,
      "default": "default",
      "description": "Namespace alvo"
    }
  ]
}
```
#### 4. ComunicaÃ§Ã£o via I/O PadrÃ£o
```bash
Canal  â”‚ Uso              â”‚ DescriÃ§Ã£o                                   
â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
stdout â”‚ Resultado        â”‚ SaÃ­da principal enviada para a IA           
stderr â”‚ Logs/Progresso   â”‚ Mensagens de status, avisos e erros         
stdin  â”‚ Entrada de dados â”‚ Blocos grandes de texto (ex: cÃ³digo gerado)
args   â”‚ ParÃ¢metros       â”‚ Argumentos de linha de comando
```
Regra de Ouro:

- âœ…  stdout : Apenas o resultado final
- âœ…  stderr : Todo o resto (logs, progresso, erros)

--------

## Exemplo Completo: Plugin  @hello  em Go

Este exemplo demonstra todas as melhores prÃ¡ticas:

> // ~/.chatcli/plugins-src/hello/main.go
```go
package main

import (
    "encoding/json"
    "flag"
    "fmt"
    "os"
    "time"
)

// Metadata define a estrutura para --metadata
type Metadata struct {
    Name        string `json:"name"`
    Description string `json:"description"`
    Usage       string `json:"usage"`
    Version     string `json:"version"`
}

// Schema define a estrutura para --schema
type Schema struct {
    Parameters []Parameter `json:"parameters"`
}

type Parameter struct {
    Name        string `json:"name"`
    Type        string `json:"type"`
    Required    bool   `json:"required"`
    Description string `json:"description"`
    Default     string `json:"default,omitempty"`
}

// logf envia mensagens de progresso para stderr (visÃ­vel ao usuÃ¡rio)
func logf(format string, v ...interface{}) {
    fmt.Fprintf(os.Stderr, format, v...)
}

func main() {
    // Flags de descoberta
    metadataFlag := flag.Bool("metadata", false, "Exibe os metadados do plugin")
    schemaFlag := flag.Bool("schema", false, "Exibe o schema de parÃ¢metros")
    flag.Parse()

    // Responder --metadata
    if *metadataFlag {
        meta := Metadata{
            Name:        "@hello",
            Description: "Plugin de exemplo que demonstra o fluxo stdout/stderr",
            Usage:       "@hello [seu-nome]",
            Version:     "1.0.0",
        }
        jsonMeta, _ := json.Marshal(meta)
        fmt.Println(string(jsonMeta)) // stdout para o ChatCLI
        return
    }

    // Responder --schema
    if *schemaFlag {
        schema := Schema{
            Parameters: []Parameter{
                {
                    Name:        "nome",
                    Type:        "string",
                    Required:    false,
                    Description: "Nome da pessoa a ser cumprimentada",
                    Default:     "Mundo",
                },
            },
        }
        jsonSchema, _ := json.Marshal(schema)
        fmt.Println(string(jsonSchema)) // stdout para o ChatCLI
        return
    }

    // LÃ³gica principal do plugin
    logf("ğŸš€ Plugin 'hello' iniciado!\n") // stderr = progresso visÃ­vel

    time.Sleep(2 * time.Second) // Simula trabalho
    logf("   â³ Realizando uma tarefa demorada...\n")
    time.Sleep(2 * time.Second)

    name := "Mundo"
    if len(flag.Args()) > 0 {
        name = flag.Args()[0]
    }

    logf("âœ… Tarefa concluÃ­da!\n") // stderr = feedback de progresso

    // Resultado final para stdout (serÃ¡ enviado para a IA)
    fmt.Printf("OlÃ¡, %s! A hora agora Ã© %s.", name, time.Now().Format(time.RFC1123))
}
```
### CompilaÃ§Ã£o e InstalaÃ§Ã£o

# 1. Compilar
```bash
cd ~/.chatcli/plugins-src/hello
go build -o hello main.go
```
# 2. Dar permissÃ£o de execuÃ§Ã£o (CRÃTICO!)
```bash
chmod +x hello
```
# 3. Mover para o diretÃ³rio de plugins
```bash
mv hello ~/.chatcli/plugins/
```
# 4. Verificar instalaÃ§Ã£o
```bash
â¯ /plugin list
ğŸ“¦ Plugins Instalados (1):
  â€¢ @hello  - Plugin de exemplo que demonstra o fluxo stdout/stderr
```
### Testando o Plugin

# Dentro do ChatCLI
```bash
â¯ /agent @hello Edilson
```
# SaÃ­da no terminal (stderr):
```bash
ğŸš€ Plugin 'hello' iniciado!
   â³ Realizando uma tarefa demorada...
âœ… Tarefa concluÃ­da!
```
# Resposta da IA (baseada no stdout):
> O plugin retornou: "OlÃ¡, Edilson! A hora agora Ã© Mon, 02 Jan 2024 14:30:00 UTC."

--------

## Debugging de Plugins

### Verificar se o Plugin Foi Carregado

> â¯ /plugin list

Se o plugin nÃ£o aparecer:

1. Verifique permissÃµes:
ls -l ~/.chatcli/plugins/

Deve mostrar -rwxr-xr-x (com 'x')

2. Teste o contrato  --metadata :
> ~/.chatcli/plugins/seu-plugin --metadata

Deve retornar JSON vÃ¡lido

3. Ative logs de debug:

No .env
```bash
LOG_LEVEL=debug
ENV=dev
```

### Testar Plugin Manualmente

Antes de usar no agente, teste diretamente:

- Testar metadados
  - ~/.chatcli/plugins/seu-plugin --metadata

- Testar schema
  - ~/.chatcli/plugins/seu-plugin --schema

- Testar execuÃ§Ã£o
  - ~/.chatcli/plugins/seu-plugin arg1 arg2

### Resolver Problemas de Timeout

Se o plugin estÃ¡ sendo interrompido:

- Aumentar timeout globalmente
  - export CHATCLI_AGENT_PLUGIN_TIMEOUT=30m

- Ou no .env
  - CHATCLI_AGENT_PLUGIN_TIMEOUT=30m

--------

## Exemplo AvanÃ§ado: Plugin Docker Hub

Este exemplo demonstra integraÃ§Ã£o com API externa:

// chatcli-plugin-dockerhub/main.go
```go
package main

import (
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os"
    "strings"
    "time"
)

type Metadata struct {
    Name        string `json:"name"`
    Description string `json:"description"`
    Usage       string `json:"usage"`
    Version     string `json:"version"`
}

type DockerHubResponse struct {
    Results []struct {
        Name string `json:"name"`
    } `json:"results"`
}

func main() {
    if len(os.Args) > 1 && os.Args[1] == "--metadata" {
        meta := Metadata{
            Name:        "@dockerhub",
            Description: "Consulta tags disponÃ­veis de uma imagem no Docker Hub",
            Usage:       "@dockerhub <imagem>",
            Version:     "1.0.0",
        }
        jsonMeta, _ := json.Marshal(meta)
        fmt.Println(string(jsonMeta))
        return
    }

    if len(os.Args) < 2 {
        fmt.Fprintln(os.Stderr, "âŒ Erro: Nome da imagem Ã© obrigatÃ³rio.")
        fmt.Fprintln(os.Stderr, "ğŸ’¡ Uso: @dockerhub <imagem>")
        os.Exit(1)
    }

    imageName := os.Args[1]
    fmt.Fprintf(os.Stderr, "ğŸ” Consultando tags para '%s'...\n", imageName)

    // Chamada Ã  API do Docker Hub
    url := fmt.Sprintf("https://hub.docker.com/v2/repositories/library/%s/tags?page_size=25", imageName)
    client := &http.Client{Timeout: 10 * time.Second}
    resp, err := client.Get(url)
    if err != nil {
        fmt.Fprintf(os.Stderr, "âŒ Erro na requisiÃ§Ã£o: %v\n", err)
        os.Exit(1)
    }
    defer resp.Body.Close()

    body, _ := io.ReadAll(resp.Body)
    var apiResponse DockerHubResponse
    if err := json.Unmarshal(body, &apiResponse); err != nil {
        fmt.Fprintf(os.Stderr, "âŒ Erro ao parsear resposta: %v\n", err)
        os.Exit(1)
    }

    // Extrair tags
    var tags []string
    for _, result := range apiResponse.Results {
        tags = append(tags, result.Name)
    }

    fmt.Fprintf(os.Stderr, "âœ… %d tags encontradas\n", len(tags))

    // Resultado final para stdout (para a IA)
    fmt.Println(strings.Join(tags, "\n"))
}
```
### Caso de Uso

> â¯ /agent implante a Ãºltima versÃ£o alpine do redis

- O agente irÃ¡:
    - 1. Usar @dockerhub redis para listar tags
    - 2. Filtrar tags com "alpine"
    - 3. Selecionar a versÃ£o mais recente
    - 4. Executar `docker run redis:<tag-alpine>`
    - 5. Validar que o container estÃ¡ rodando

--------

## Linguagens Suportadas

Qualquer linguagem que possa:

- Criar um executÃ¡vel
- Interagir com I/O padrÃ£o (stdin/stdout/stderr)
- Processar argumentos de linha de comando

### RecomendaÃ§Ãµes por Caso de Uso
```bash
Linguagem â”‚ Melhor Para         â”‚ Vantagens                              
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Go        â”‚ Plugins de produÃ§Ã£o â”‚ BinÃ¡rios estÃ¡ticos, rÃ¡pidos, portÃ¡teis
Rust      â”‚ Performance crÃ­tica â”‚ SeguranÃ§a de memÃ³ria, velocidade       
Python    â”‚ Prototipagem rÃ¡pida â”‚ Ecossistema rico, fÃ¡cil debugging      
Bash      â”‚ Scripts de sistema  â”‚ IntegraÃ§Ã£o nativa com shell            
Node.js   â”‚ IntegraÃ§Ã£o com APIs â”‚ NPM, async/await
```
--------

## SeguranÃ§a e Melhores PrÃ¡ticas

### ValidaÃ§Ã£o de Entrada
```go
if len(os.Args) < 2 {
    fmt.Fprintln(os.Stderr, "âŒ Erro: Argumentos insuficientes")
    os.Exit(1)
}
```
### Tratamento de Erros
```go
if err != nil {
    fmt.Fprintf(os.Stderr, "âŒ Erro: %v\n", err)
    os.Exit(1) // Exit code != 0 sinaliza erro para o ChatCLI
}
```
### Timeouts Internos
```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()
```
### Logs Informativos
```go
fmt.Fprintln(os.Stderr, "â³ Iniciando operaÃ§Ã£o demorada...")
fmt.Fprintln(os.Stderr, "   - Etapa 1 de 3...")
fmt.Fprintln(os.Stderr, "âœ… OperaÃ§Ã£o concluÃ­da!")
```
--------

## Plugins no Modo /coder

O modo [/coder](/core-concepts/coder-mode/) Ã© especializado em engenharia de software e depende do plugin [@coder](/features/coder-plugin/) para executar suas aÃ§Ãµes.

No `/coder`, a IA emite chamadas de ferramenta em um formato estrito:

- Primeiro, escreve um `<reasoning>` curto (2 a 6 linhas)
- Em seguida, emite apenas um `<tool_call name="@coder" args="..."/>`
- JSON em `args` Ã© recomendado

Exemplos de chamadas reais (que a IA emite no /coder):

```text
<tool_call name="@coder" args="{\"cmd\":\"tree\",\"args\":{\"dir\":\".\"}}"/>
<tool_call name="@coder" args="{\"cmd\":\"read\",\"args\":{\"file\":\"cli/agent_mode.go\"}}"/>
<tool_call name="@coder" args="{\"cmd\":\"test\",\"args\":{\"dir\":\".\"}}"/>
```

Veja mais em [Modo Coder](/core-concepts/coder-mode/) e [Plugin @coder](/features/coder-plugin/).

--------

## PrÃ³ximos Passos

1. Explore os plugins de exemplo em  ~/.chatcli/plugins-examples/
2. Crie seu primeiro plugin seguindo o template  @hello
3. Compartilhe plugins com a comunidade via GitHub
4. Contribua com plugins para o ecossistema ChatCLI

--------

## Recursos Adicionais

â€¢ Exemplos de Plugins https://github.com/diillson/chatcli/tree/main/plugins-examples

--------

O sistema de plugins Ã© a sua porta de entrada para a verdadeira automaÃ§Ã£o. Comece a construir suas ferramentas e transforme seu terminal em um colega de equipe.
